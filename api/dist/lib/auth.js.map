{
  "version": 3,
  "sources": ["../../src/lib/auth.js"],
  "sourcesContent": ["import { AuthenticationError, ForbiddenError } from '@redwoodjs/graphql-server'\n\nimport { db } from './db'\n\n/**\n * The session object sent in as the first argument to getCurrentUser() will\n * have a single key `id` containing the unique ID of the logged in user\n * (whatever field you set as `authFields.id` in your auth function config).\n * You'll need to update the call to `db` below if you use a different model\n * name or unique field name, for example:\n *\n *   return await db.profile.findUnique({ where: { email: session.id } })\n *                   \u2500\u2500\u2500\u252C\u2500\u2500\u2500                       \u2500\u2500\u252C\u2500\u2500\n *      model accessor \u2500\u2518      unique id field name \u2500\u2518\n *\n * !! BEWARE !! Anything returned from this function will be available to the\n * client--it becomes the content of `currentUser` on the web side (as well as\n * `context.currentUser` on the api side). You should carefully add additional\n * fields to the `select` object below once you've decided they are safe to be\n * seen if someone were to open the Web Inspector in their browser.\n */\nexport const getCurrentUser = async (session) => {\n  if (!session || typeof session.id !== 'number') {\n    return null\n  }\n\n  return await db.user.findUnique({\n    where: { id: session.id },\n    select: { id: true, email: true, roles: true, },\n  })\n}\n\n/**\n * The user is authenticated if there is a currentUser in the context\n *\n * @returns {boolean} - If the currentUser is authenticated\n */\nexport const isAuthenticated = () => {\n  return !!context.currentUser\n}\n\n/**\n * When checking role membership, roles can be a single value, a list, or none.\n * You can use Prisma enums too (if you're using them for roles), just import your enum type from `@prisma/client`\n */\n\n/**\n * Checks if the currentUser is authenticated (and assigned one of the given roles)\n *\n * @param roles: {@link AllowedRoles} - Checks if the currentUser is assigned one of these roles\n *\n * @returns {boolean} - Returns true if the currentUser is logged in and assigned one of the given roles,\n * or when no roles are provided to check against. Otherwise returns false.\n */\nexport const hasRole = (roles) => {\n  if (!isAuthenticated()) {\n    return false\n  }\n\n  const currentUserRoles = context.currentUser?.roles\n\n  if (typeof roles === 'string') {\n    if (typeof currentUserRoles === 'string') {\n      // roles to check is a string, currentUser.roles is a string\n      return currentUserRoles === roles\n    } else if (Array.isArray(currentUserRoles)) {\n      // roles to check is a string, currentUser.roles is an array\n      return currentUserRoles?.some((allowedRole) => roles === allowedRole)\n    }\n  }\n\n  if (Array.isArray(roles)) {\n    if (Array.isArray(currentUserRoles)) {\n      // roles to check is an array, currentUser.roles is an array\n      return currentUserRoles?.some((allowedRole) =>\n        roles.includes(allowedRole)\n      )\n    } else if (typeof currentUserRoles === 'string') {\n      // roles to check is an array, currentUser.roles is a string\n      return roles.some((allowedRole) => currentUserRoles === allowedRole)\n    }\n  }\n\n  // roles not found\n  return false\n}\n\n/**\n * Use requireAuth in your services to check that a user is logged in,\n * whether or not they are assigned a role, and optionally raise an\n * error if they're not.\n *\n * @param roles: {@link AllowedRoles} - When checking role membership, these roles grant access.\n *\n * @returns - If the currentUser is authenticated (and assigned one of the given roles)\n *\n * @throws {@link AuthenticationError} - If the currentUser is not authenticated\n * @throws {@link ForbiddenError} If the currentUser is not allowed due to role permissions\n *\n * @see https://github.com/redwoodjs/redwood/tree/main/packages/auth for examples\n */\nexport const requireAuth = ({ roles } = {}) => {\n  if (!isAuthenticated()) {\n    throw new AuthenticationError(\"You don't have permission to do that.\")\n  }\n\n  if (roles && !hasRole(roles)) {\n    throw new ForbiddenError(\"You don't have access to do that.\")\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,4BAAoD;AAEpD,gBAAmB;AAmBZ,MAAMA,iBAAiB,OAAOC,YAAY;AAC/C,MAAI,CAACA,WAAW,OAAOA,QAAQC,OAAO,UAAU;AAC9C,WAAO;EACR;AAED,SAAO,MAAMC,aAAGC,KAAKC,WAAW;IAC9BC,OAAO;MAAEJ,IAAID,QAAQC;IAAd;IACPK,QAAQ;MAAEL,IAAI;MAAMM,OAAO;MAAMC,OAAO;IAAhC;EAFsB,CAAnB;AAId;AAOM,MAAMC,kBAAkB,MAAM;AACnC,SAAO,CAAC,CAACC,8BAAQC;AAClB;AAeM,MAAMC,UAAWJ,WAAU;;AAChC,MAAI,CAACC,gBAAe,GAAI;AACtB,WAAO;EACR;AAED,QAAMI,oBAAmBH,mCAAQC,gBAARD,mBAAqBF;AAE9C,MAAI,OAAOA,UAAU,UAAU;AAC7B,QAAI,OAAOK,qBAAqB,UAAU;AAExC,aAAOA,qBAAqBL;IAC7B,eAAU,gBAAAM,SAAcD,gBAAd,GAAiC;AAE1C,aAAOA,qDAAkBE,KAAMC,iBAAgBR,UAAUQ;IAC1D;EACF;AAED,UAAI,gBAAAF,SAAcN,KAAd,GAAsB;AACxB,YAAI,gBAAAM,SAAcD,gBAAd,GAAiC;AAEnC,aAAOA,qDAAkBE,KAAMC,qBAC7B,gBAAAC,SAAAT,KAAK,EAAA,KAALA,OAAeQ,WAAV;IAER,WAAU,OAAOH,qBAAqB,UAAU;AAE/C,iBAAO,YAAAK,SAAAV,KAAK,EAAA,KAALA,OAAYQ,iBAAgBH,qBAAqBG,WAA5C;IACb;EACF;AAGD,SAAO;AACR;AAgBM,MAAMG,cAAc,CAAC;EAAEX;AAAF,IAAY,CAAA,MAAO;AAC7C,MAAI,CAACC,gBAAe,GAAI;AACtB,UAAM,IAAIW,0CAAoB,uCAAxB;EACP;AAED,MAAIZ,SAAS,CAACI,QAAQJ,KAAD,GAAS;AAC5B,UAAM,IAAIa,qCAAe,mCAAnB;EACP;AACF;",
  "names": ["getCurrentUser", "session", "id", "db", "user", "findUnique", "where", "select", "email", "roles", "isAuthenticated", "context", "currentUser", "hasRole", "currentUserRoles", "_Array$isArray", "some", "allowedRole", "_includesInstanceProperty", "_someInstanceProperty", "requireAuth", "AuthenticationError", "ForbiddenError"]
}
