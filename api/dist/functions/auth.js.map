{
  "version": 3,
  "sources": ["../../src/functions/auth.js"],
  "sourcesContent": ["import { DbAuthHandler } from '@redwoodjs/api'\n\nimport { db } from 'src/lib/db'\n\nconst nodemailer = require('nodemailer')\n\nexport const handler = async (event, context) => {\n  const forgotPasswordOptions = {\n    // handler() is invoked after verifying that a user was found with the given\n    // username. This is where you can send the user an email with a link to\n    // reset their password. With the default dbAuth routes and field names, the\n    // URL to reset the password will be:\n    //\n    // https://example.com/reset-password?resetToken=${user.resetToken}\n    //\n    // Whatever is returned from this function will be returned from\n    // the `forgotPassword()` function that is destructured from `useAuth()`\n    // You could use this return value to, for example, show the email\n    // address in a toast message so the user will know it worked and where\n    // to look for the email.\n    handler: async (user) => {\n      try {\n        let transporter = nodemailer.createTransport({\n          host: process.env.SMTP_HOST,\n          port: process.env.SMTP_PORT,\n          secure: true,\n          auth: {\n            user: process.env.SMTP_USER,\n            pass: process.env.SMTP_PASS,\n          },\n        })\n        const resetLink = `${process.env.APP_URL}/reset-password?resetToken=${user.resetToken}`\n        const message = {\n          from: process.env.AUTH_EMAIL_FROM,\n          to: user.email,\n          subject: 'Reset Forgotten Password',\n          html: `Click on the link below to reset your password. It will expire after 24hrs. <p><a href=\"${resetLink}\">Reset Password</a></p><p>or copy and paste the link below into a web browser:</p><p>${resetLink}</p>`,\n        }\n        await transporter.sendMail(message)\n      } catch (err) {\n        console.log(err)\n        logger.error(err)\n      }\n      return user\n    },\n\n    // How long the resetToken is valid for, in seconds (default is 24 hours)\n    expires: 60 * 60 * 24,\n\n    errors: {\n      // for security reasons you may want to be vague here rather than expose\n      // the fact that the email address wasn't found (prevents fishing for\n      // valid email addresses)\n      usernameNotFound: \"If an account exists, an email will be sent to reset your password in the next few minutes. Please check your spam/junk folder if you don't see it in your inbox.\",\n      // if the user somehow gets around client validation\n      usernameRequired: \"If an account exists, an email will be sent to reset your password in the next few minutes. Please check your spam/junk folder if you don't see it in your inbox.\",\n    },\n  }\n\n  const loginOptions = {\n    // handler() is called after finding the user that matches the\n    // username/password provided at login, but before actually considering them\n    // logged in. The `user` argument will be the user in the database that\n    // matched the username/password.\n    //\n    // If you want to allow this user to log in simply return the user.\n    //\n    // If you want to prevent someone logging in for another reason (maybe they\n    // didn't validate their email yet), throw an error and it will be returned\n    // by the `logIn()` function from `useAuth()` in the form of:\n    // `{ message: 'Error message' }`\n    handler: (user) => {\n      return user\n    },\n\n    errors: {\n      // usernameOrPasswordMissing: 'Both username and password are required',\n      usernameOrPasswordMissing: 'Invalid credentials',\n      // usernameNotFound: 'Username ${username} not found',\n      usernameNotFound: 'Invalid credentials',\n      // For security reasons you may want to make this the same as the\n      // usernameNotFound error so that a malicious user can't use the error\n      // to narrow down if it's the username or password that's incorrect\n      // incorrectPassword: 'Incorrect password for ${username}',\n      incorrectPassword: 'Invalid credentials',\n    },\n\n    // How long a user will remain logged in, in seconds\n    expires: 60 * 60 * 24 * 365 * 10,\n  }\n\n  const resetPasswordOptions = {\n    // handler() is invoked after the password has been successfully updated in\n    // the database. Returning anything truthy will automatically logs the user\n    // in. Return `false` otherwise, and in the Reset Password page redirect the\n    // user to the login page.\n    handler: (_user) => {\n      return true\n    },\n\n    // If `false` then the new password MUST be different than the current one\n    allowReusedPassword: true,\n\n    errors: {\n      // the resetToken is valid, but expired\n      resetTokenExpired: 'resetToken is expired',\n      // no user was found with the given resetToken\n      resetTokenInvalid: 'resetToken is invalid',\n      // the resetToken was not present in the URL\n      resetTokenRequired: 'resetToken is required',\n      // new password is the same as the old password (apparently they did not forget it)\n      reusedPassword: 'Must choose a new password',\n    },\n  }\n\n  const signupOptions = {\n    // Whatever you want to happen to your data on new user signup. Redwood will\n    // check for duplicate usernames before calling this handler. At a minimum\n    // you need to save the `username`, `hashedPassword` and `salt` to your\n    // user table. `userAttributes` contains any additional object members that\n    // were included in the object given to the `signUp()` function you got\n    // from `useAuth()`.\n    //\n    // If you want the user to be immediately logged in, return the user that\n    // was created.\n    //\n    // If this handler throws an error, it will be returned by the `signUp()`\n    // function in the form of: `{ error: 'Error message' }`.\n    //\n    // If this returns anything else, it will be returned by the\n    // `signUp()` function in the form of: `{ message: 'String here' }`.\n    handler: ({ username, hashedPassword, salt, userAttributes }) => {\n      return db.user.create({\n        data: {\n          email: username,\n          hashedPassword: hashedPassword,\n          salt: salt,\n          // name: userAttributes.name\n        },\n      })\n    },\n\n    errors: {\n      // `field` will be either \"username\" or \"password\"\n      fieldMissing: '${field} is required',\n      usernameTaken: '\"${username}\" already in use',\n    },\n  }\n\n  const authHandler = new DbAuthHandler(event, context, {\n    // Provide prisma db client\n    db: db,\n\n    // The name of the property you'd call on `db` to access your user table.\n    // ie. if your Prisma model is named `User` this value would be `user`, as in `db.user`\n    authModelAccessor: 'user',\n\n    // The name of the property you'd call on `db` to access your user credentials table.\n    // ie. if your Prisma model is named `UserCredential` this value would be `userCredential`, as in `db.userCredential`\n    credentialModelAccessor: 'userCredential',\n\n    // A map of what dbAuth calls a field to what your database calls it.\n    // `id` is whatever column you use to uniquely identify a user (probably\n    // something like `id` or `userId` or even `email`)\n    authFields: {\n      id: 'id',\n      username: 'email',\n      hashedPassword: 'hashedPassword',\n      salt: 'salt',\n      resetToken: 'resetToken',\n      resetTokenExpiresAt: 'resetTokenExpiresAt',\n      challenge: 'webAuthnChallenge',\n    },\n\n    // Specifies attributes on the cookie that dbAuth sets in order to remember\n    // who is logged in. See https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies\n    cookie: {\n      HttpOnly: true,\n      Path: '/',\n      SameSite: 'Strict',\n      Secure: process.env.NODE_ENV !== 'development' ? true : false,\n\n      // If you need to allow other domains (besides the api side) access to\n      // the dbAuth session cookie:\n      // Domain: 'example.com',\n    },\n\n    forgotPassword: forgotPasswordOptions,\n    login: loginOptions,\n    resetPassword: resetPasswordOptions,\n    signup: signupOptions,\n\n    // See https://redwoodjs.com/docs/authentication/dbauth#webauthn for options\n    webAuthn: {\n      enabled: true, // false disables WebAuthn authentication\n      // How long to allow re-auth via WebAuthn in seconds (default is 10 years).\n      // The `login.expires` time denotes how many seconds before a user will be\n      // logged out, and this value is how long they'll be to continue to use a\n      // fingerprint/face scan to log in again. When this one expires they\n      // *must* re-enter username and password to authenticate (WebAuthn will\n      // then be re-enabled for this amount of time).\n      expires: 60 * 60 * 24 * 365 * 10,\n      name: 'Redwood Application',\n      domain:\n        process.env.NODE_ENV === 'development' ? 'localhost' : 'server.com',\n      origin:\n        process.env.NODE_ENV === 'development'\n          ? 'http://localhost:8910'\n          : 'https://server.com',\n      type: 'platform',\n      timeout: 60000,\n      credentialFields: {\n        id: 'id',\n        userId: 'userId',\n        publicKey: 'publicKey',\n        transports: 'transports',\n        counter: 'counter',\n      },\n    },\n  })\n\n  return await authHandler.invoke()\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;AAAA;;;;;iBAA8B;AAE9B,gBAAA;AAEA,MAAMA,aAAaC,QAAQ,YAAD;AAEnB,MAAMC,UAAU,OAAOC,OAAOC,YAAY;AAC/C,QAAMC,wBAAwB;IAa5BH,SAAS,OAAOI,SAAS;AACvB,UAAI;AACF,YAAIC,cAAcP,WAAWQ,gBAAgB;UAC3CC,MAAMC,QAAQC,IAAIC;UAClBC,MAAMH,QAAQC,IAAIG;UAClBC,QAAQ;UACRC,MAAM;YACJV,MAAMI,QAAQC,IAAIM;YAClBC,MAAMR,QAAQC,IAAIQ;UAFd;QAJqC,CAA3B;AASlB,cAAMC,YAAa,GAAEV,QAAQC,IAAIU,qCAAqCf,KAAKgB;AAC3E,cAAMC,UAAU;UACdC,MAAMd,QAAQC,IAAIc;UAClBC,IAAIpB,KAAKqB;UACTC,SAAS;UACTC,MAAO,2FAA0FT,kGAAkGA;QAJrL;AAMhB,cAAMb,YAAYuB,SAASP,OAArB;MACP,SAAQQ,KAAP;AACAC,gBAAQC,IAAIF,GAAZ;AACAG,eAAOC,MAAMJ,GAAb;MACD;AACD,aAAOzB;IACR;IAGD8B,SAAS,KAAK,KAAK;IAEnBC,QAAQ;MAINC,kBAAkB;MAElBC,kBAAkB;IANZ;EA1CoB;AAoD9B,QAAMC,eAAe;IAYnBtC,SAAUI,UAAS;AACjB,aAAOA;IACR;IAED+B,QAAQ;MAENI,2BAA2B;MAE3BH,kBAAkB;MAKlBI,mBAAmB;IATb;IAaRN,SAAS,KAAK,KAAK,KAAK,MAAM;EA7BX;AAgCrB,QAAMO,uBAAuB;IAK3BzC,SAAU0C,WAAU;AAClB,aAAO;IACR;IAGDC,qBAAqB;IAErBR,QAAQ;MAENS,mBAAmB;MAEnBC,mBAAmB;MAEnBC,oBAAoB;MAEpBC,gBAAgB;IARV;EAZmB;AAwB7B,QAAMC,gBAAgB;IAgBpBhD,SAAS,CAAC;MAAEiD;MAAUC;MAAgBC;MAAMC;IAAlC,MAAuD;AAC/D,aAAOC,aAAGjD,KAAKkD,OAAO;QACpBC,MAAM;UACJ9B,OAAOwB;UACPC;UACAC;QAHI;MADc,CAAf;IAQR;IAEDhB,QAAQ;MAENqB,cAAc;MACdC,eAAe;IAHT;EA3BY;AAkCtB,QAAMC,cAAc,IAAIC,yBAAc1D,OAAOC,SAAS;IAEpDmD,IAAIA;IAIJO,mBAAmB;IAInBC,yBAAyB;IAKzBC,YAAY;MACVC,IAAI;MACJd,UAAU;MACVC,gBAAgB;MAChBC,MAAM;MACN/B,YAAY;MACZ4C,qBAAqB;MACrBC,WAAW;IAPD;IAYZC,QAAQ;MACNC,UAAU;MACVC,MAAM;MACNC,UAAU;MACVC,QAAQ9D,QAAQC,IAAI8D,aAAa,gBAAgB,OAAO;IAJlD;IAWRC,gBAAgBrE;IAChBsE,OAAOnC;IACPoC,eAAejC;IACfkC,QAAQ3B;IAGR4B,UAAU;MACRC,SAAS;MAOT3C,SAAS,KAAK,KAAK,KAAK,MAAM;MAC9B4C,MAAM;MACNC,QACEvE,QAAQC,IAAI8D,aAAa,gBAAgB,cAAc;MACzDS,QACExE,QAAQC,IAAI8D,aAAa,gBACrB,0BACA;MACNU,MAAM;MACNC,SAAS;MACTC,kBAAkB;QAChBpB,IAAI;QACJqB,QAAQ;QACRC,WAAW;QACXC,YAAY;QACZC,SAAS;MALO;IAlBV;EA5C0C,CAAlC;AAwEpB,SAAO,MAAM7B,YAAY8B,OAAZ;AACd;",
  "names": ["nodemailer", "require", "handler", "event", "context", "forgotPasswordOptions", "user", "transporter", "createTransport", "host", "process", "env", "SMTP_HOST", "port", "SMTP_PORT", "secure", "auth", "SMTP_USER", "pass", "SMTP_PASS", "resetLink", "APP_URL", "resetToken", "message", "from", "AUTH_EMAIL_FROM", "to", "email", "subject", "html", "sendMail", "err", "console", "log", "logger", "error", "expires", "errors", "usernameNotFound", "usernameRequired", "loginOptions", "usernameOrPasswordMissing", "incorrectPassword", "resetPasswordOptions", "_user", "allowReusedPassword", "resetTokenExpired", "resetTokenInvalid", "resetTokenRequired", "reusedPassword", "signupOptions", "username", "hashedPassword", "salt", "userAttributes", "db", "create", "data", "fieldMissing", "usernameTaken", "authHandler", "DbAuthHandler", "authModelAccessor", "credentialModelAccessor", "authFields", "id", "resetTokenExpiresAt", "challenge", "cookie", "HttpOnly", "Path", "SameSite", "Secure", "NODE_ENV", "forgotPassword", "login", "resetPassword", "signup", "webAuthn", "enabled", "name", "domain", "origin", "type", "timeout", "credentialFields", "userId", "publicKey", "transports", "counter", "invoke"]
}
